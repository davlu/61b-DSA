package byow.Core;

import byow.TileEngine.TETile;
import byow.TileEngine.Tileset;
import edu.princeton.cs.introcs.StdDraw;

import java.awt.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Collections;
import java.util.Random;

/**
 * Takes seed and generates pseudorandom world accordingly
 *
 * Big picture idea: Rooms and hallways are subclasses. A room has dimensions of
 * at least 2x2 internally (4x4 externally). A hallway has internal width 1 and is
 * either horizontal or vertical. Rooms spawn randomly spawn hallways, and hallways randomly
 * spawn rooms. This is a recursive process that terminates when validation attempts fail
 * (i.e., world fills up).
 */
public class Generator {

    private final Random random;
    private TETile[][] tiles;
    private int worldWidth, worldHeight;
    private int avatarX;
    private int avatarY;

    static final int MIN = 4, MAX = 9; // Min and max side lengths for a room or hallway

    /**
     *
     * @return A valid, random side length
     */
    private int getLength() {
        return MIN + random.nextInt(MAX + 1 - MIN);
    }

    /* Represents a room*/
    private class Room {

        protected int roomWidth, roomHeight, x, y; // Coordinates of bottom-left corner
        protected static final int TOP = 0, LEFT = 1, BOTTOM = 2, RIGHT = 3;


        /**
         * Dimension of a room is relative to the hallway that spawned it. If a
         * hallway spawned this room on top of itself, the dimension of the *room* is TOP.
         * Entrance coordinate describes the x coordinate (if vertical) or y coordinate
         * (if horizontal) of the hallway that spawned this room.
         * For the starting room, these values are both Integer.MAX_VALUE
         */
        int dimension, entranceCoord;


        /**
         * @return - Whether or not room can be placed here
         */
        boolean validate() {
            if (roomWidth < 3 || roomHeight < 3) {
                return false;
            }
            if (x < 0 || y < 0 || x + roomWidth >= worldWidth
                    || y + roomHeight >= worldHeight) {
                return false;
            }
            for (int i = 0; i < roomWidth; i++) {
                for (int j = 0; j < roomHeight; j++) {
                    if (tiles[x + i][y + j] != Tileset.NOTHING) {
                        return false;
                    }
                }
            }
            return true;
        }

        Room(int x, int y, int roomWidth, int roomHeight, int dimension,
                    int entranceCoord) {
            this.x = x;
            this.y = y;
            this.roomHeight = roomHeight;
            this.roomWidth = roomWidth;
            this.dimension = dimension;
            this.entranceCoord = entranceCoord;
        }

        Room(int x, int y, int roomWidth, int roomHeight) {
            this(x, y, roomWidth, roomHeight, Integer.MAX_VALUE, Integer.MAX_VALUE);

        }

        /**
         * Draws itself to the tile array. Does not take connections with hallways
         * into account.
         */
        void draw() {
            for (int i = 0; i < roomWidth; i++) {
                tiles[i + x][y] = Tileset.WALL;
                tiles[i + x][y + roomHeight - 1] = Tileset.WALL;
            }
            for (int i = 0; i < roomHeight; i++) {
                tiles[x][y + i] = Tileset.WALL;
                tiles[x + roomWidth - 1][y + i] = Tileset.WALL;
            }
            for (int i = 1; i < roomWidth - 1; i++) {
                for (int j = 1; j < roomHeight - 1; j++) {
                    tiles[i + x][j + y] = Tileset.FLOOR;
                }
            }
            if(dimension == Integer.MAX_VALUE){
                avatarX = (roomWidth/2)+x;
                avatarY = (roomHeight/2)+y;
                tiles[avatarX][avatarY] = Tileset.AVATAR;
            }
            connect();
        }

        /**
         * Based on entranceCoord, connects drawing of this room with the hallway that spawned it.
         */
        void connect() {
            if (entranceCoord == Integer.MAX_VALUE) {
                return;
            }
            if (dimension == TOP) {
                tiles[entranceCoord + 1][y] = Tileset.FLOOR;
                tiles[entranceCoord + 1][y - 1] = Tileset.FLOOR;
            } else if (dimension == BOTTOM) {
                tiles[entranceCoord + 1][y + roomHeight] = Tileset.FLOOR;
                tiles[entranceCoord + 1][y + roomHeight - 1] = Tileset.FLOOR;
            } else if (dimension == RIGHT) {
                tiles[x][entranceCoord + 1] = Tileset.FLOOR;
                tiles[x - 1][entranceCoord + 1] = Tileset.FLOOR;
            } else if (dimension == LEFT) {
                tiles[x + roomWidth][entranceCoord + 1] = Tileset.FLOOR;
                tiles[x + roomWidth - 1][entranceCoord + 1] = Tileset.FLOOR;
            }
        }

        void spawn() {
            if (!validate()) {
                return;
            }
            draw();
            ArrayList<Hallway> spawned = new ArrayList<>();
            for (int i = 0; i < 4; i++) {
                if (i == TOP || i == BOTTOM) {
                    int spawnLocation = x + random.nextInt(roomWidth - 2);
                    int height = getLength();
                    if (i == TOP) {
                        spawned.add(new Hallway(spawnLocation, y + roomHeight,
                                3, height, TOP));
                    } else {
                        spawned.add(new Hallway(spawnLocation, y - height, 3,
                                height, BOTTOM));
                    }
                } else {
                    int spawnLocation = y + random.nextInt(roomHeight - 2);
                    int width = getLength();
                    if (i == RIGHT) {
                        spawned.add(new Hallway(x + roomWidth, spawnLocation,
                                width, 3, RIGHT));
                    } else if (i == LEFT) {
                        spawned.add(new Hallway(x - width, spawnLocation, width,
                                3, LEFT));
                    }
                }

            }
            Collections.shuffle(spawned, random);
            for (Hallway h : spawned) {
                h.spawn();
            }
        }
    }

    private class Hallway extends Room {

        /* These positions are relative to the room which spawned this hallway;
           top means the hallway is above a room.
         */

        static final int MIN = 4;
        static final int MAX = 10;


        Hallway(int x, int y, int width, int height, int dimension) {
            super(x, y, width, height);
            this.dimension = dimension;
        }

        @Override
        boolean validate() {
            boolean correctDimension = ((dimension == LEFT || dimension == RIGHT)
                    && roomHeight == 3) || ((dimension == TOP || dimension == BOTTOM)
                    && roomWidth == 3);
            return super.validate() && correctDimension;
        }

        @Override
        void connect() {
            if (dimension == TOP) {
                tiles[x + 1][y] = Tileset.FLOOR;
                tiles[x + 1][y - 1] = Tileset.FLOOR;
            } else if (dimension == BOTTOM) {
                tiles[x + 1][y + roomHeight] = Tileset.FLOOR;
                tiles[x + 1][y + roomHeight - 1] = Tileset.FLOOR;
            } else if (dimension == RIGHT) {
                tiles[x][y + 1] = Tileset.FLOOR;
                tiles[x - 1][y + 1] = Tileset.FLOOR;
            } else if (dimension == LEFT) {
                tiles[x + roomWidth][y + 1] = Tileset.FLOOR;
                tiles[x + roomWidth - 1][y + 1] = Tileset.FLOOR;
            }
        }

        @Override
        void spawn() {
            if (!validate()) {
                return;
            }
            draw();
            ArrayList<Room> spawned = new ArrayList<>();
            for (int i = 0; i < 4; i++) {
                if (i == (dimension + 2) % 4) {
                    continue;
                }
                int spawnWidth = getLength();
                int spawnHeight = getLength();
                if (i == TOP) {
                    if (dimension == TOP) {
                        spawned.add(new Room(x - random.nextInt(spawnWidth - 3),
                                y + roomHeight, spawnWidth, spawnHeight, TOP, x));
                    } else {
                        int spawnLocation = x + random.nextInt(roomWidth - 3);
                        int height = getLength();
                        spawned.add(new Hallway(spawnLocation, y + 3, 3, height, TOP));
                    }
                } else if (i == BOTTOM) {
                    if (dimension == BOTTOM) {
                        spawned.add(new Room(x - random.nextInt(spawnWidth - 3),
                                y - spawnHeight, spawnWidth, spawnHeight, BOTTOM, x));
                    } else {
                        int spawnLocation = x + random.nextInt(roomWidth - 2);
                        int height = getLength();
                        spawned.add(new Hallway(spawnLocation, y - height, 3, height, BOTTOM));
                    }
                } else if (i == LEFT) {
                    if (dimension == LEFT) {
                        spawned.add(new Room(x - 1, y - random.nextInt(spawnHeight - 3),
                                spawnWidth, spawnHeight, LEFT, y));
                    } else {
                        int spawnLocation = y + random.nextInt(roomHeight - 2);
                        int width = getLength();
                        spawned.add(new Hallway(x - width, spawnLocation, width, 3,
                                LEFT));
                    }
                } else if (i == RIGHT) {
                    if (dimension == RIGHT) {
                        spawned.add(new Room(x + roomWidth, y - random.nextInt(spawnHeight - 2),
                                spawnWidth, spawnHeight, RIGHT, y));
                    } else {
                        int spawnLocation = y + random.nextInt(roomHeight - 2);
                        int width = getLength();
                        spawned.add(new Hallway(x + 3, spawnLocation, width, 3, RIGHT));
                    }
                }
            }
            Collections.shuffle(spawned, random);
            for (Room r : spawned) {
                r.spawn();
            }
        }
    }

    public Generator(long seed, int worldX, int worldY) {
        worldWidth = worldX;
        worldHeight = worldY;
        random = new Random(seed);
        tiles = new TETile[worldX][worldY];
    }

    public TETile[][] spawn(List<Character> moves) {
        for (int i = 0; i < worldWidth; i++) {
            for (int j = 0; j < worldHeight; j++) {
                tiles[i][j] = Tileset.NOTHING;
            }
        }
        // Normal distribution so that the starting square is roughly in the middle
        int startX = (int) RandomUtils.gaussian(random, worldWidth / 2,
                worldWidth / 20);
        int startY = (int) RandomUtils.gaussian(random, worldHeight / 2,
                worldHeight / 20);
        new Room(startX, startY, getLength(), getLength()).spawn();
        for(int i = 1; i < moves.size(); i++){
            char c = moves.get(i);
            if(c == 'w'){
                if(validateMove(0,1)){
                    tiles[avatarX][avatarY+1] = Tileset.AVATAR;
                    tiles[avatarX][avatarY] = Tileset.FLOOR;
                    avatarY+=1;
                }
                else{
                    continue;
                }
            }
            else if(c == 'a'){
                if(validateMove(-1,0)){
                    tiles[avatarX-1][avatarY] = Tileset.AVATAR;
                    tiles[avatarX][avatarY] = Tileset.FLOOR;
                    avatarX-=1;
                }
                else{
                    continue;
                }
            }
            else if(c == 's'){
                if(validateMove(0,-1)){
                    tiles[avatarX][avatarY-1] = Tileset.AVATAR;
                    tiles[avatarX][avatarY] = Tileset.FLOOR;
                    avatarY-=1;
                }
                else{
                    continue;
                }
            }
            else if(c == 'd'){
                if(validateMove(1,0)){
                    tiles[avatarX+1][avatarY] = Tileset.AVATAR;
                    tiles[avatarX][avatarY] = Tileset.FLOOR;
                    avatarX+=1;
                }
                else{
                    continue;
                }
            }
            else if(c==':'){
                i++;
                c = moves.get(i);
                if(c == 'q'){
                    saveAndQuit();
                    break;
                }
            }
        }
        return tiles;
    }

    public boolean validateMove(int deltaX, int deltaY){
        if(tiles[avatarX+deltaX][avatarY+deltaY].equals(Tileset.WALL)){
            return false;
        }
        return true;
    }

    public void saveAndQuit() {

    }

}











package byow.Core;

import byow.Core.Generator;
import byow.InputDemo.InputSource;
import byow.InputDemo.KeyboardInputSource;
import byow.TileEngine.TERenderer;
import byow.TileEngine.TETile;
import edu.princeton.cs.introcs.StdDraw;

import java.awt.Color;
import java.awt.Font;


public class UI {
    public static void main(String[] args) {
        mainMenuDisplay();
        InputSource inputSource = new KeyboardInputSource();
        char c = Character.toLowerCase(inputSource.getNextKey());
        if(c == 'n'){
            System.out.println("ok");
            long seed = getSeed();
            System.out.println(seed);
            TERenderer ter = new TERenderer();
            ter.initialize(80, 50);
            Generator g = new Generator(seed, 80, 43);
            TETile[][] tiles = g.spawn();
            Avatar a = new Avatar(g.world);
            ter.renderFrame(tiles);
            wallBumpMessage();
            while(inputSource.possibleNextInput()){
                c = inputSource.getNextKey();
                a.move(c);
                ter.renderFrame(tiles);
            }
        }
        else if(c == 'l') {
            return;
        }
        else if(c == 'q'){
            System.exit(0);
        }
    }

    public static void draw(String s, int xCord, int yCord) {
        Font font = new Font("sans serif", Font.BOLD, 20);
        StdDraw.setPenColor(StdDraw.WHITE);
        StdDraw.setFont(font);
        StdDraw.text(xCord, yCord, s);
        StdDraw.show();
    }

    public static void wallBumpMessage() {
        draw("OK!!!", 10, 44);
    }

    public static void mainMenuDisplay() {
        StdDraw.setCanvasSize(40 * 16, 40 * 16);
        StdDraw.setXscale(0, 80);
        StdDraw.setYscale(0, 40);
        StdDraw.clear(Color.BLACK);
        Font font = new Font("sans serif", Font.BOLD, 40);
        Font smallerFont = new Font("sans serif", Font.CENTER_BASELINE, 25);
        StdDraw.setPenColor(StdDraw.WHITE);
        StdDraw.setFont(font);
        StdDraw.text(40, 32, "CS61B: The Game");
        StdDraw.setFont(smallerFont);
        StdDraw.text(40, 20, "New Game: (N)");
        StdDraw.text(40, 17, "Load Game: (L)");
        StdDraw.text(40, 14, "Quit Game: (Q)");
        StdDraw.show();
    }

    public static long getSeed(){
        StdDraw.setCanvasSize(40 * 16, 40 * 16);
        StdDraw.setXscale(0, 80);
        StdDraw.setYscale(0, 40);
        StdDraw.clear(Color.BLACK);
        Font font = new Font("sans serif", Font.BOLD, 40);
        StdDraw.setPenColor(StdDraw.WHITE);
        StdDraw.setFont(font);
        StdDraw.text(40, 32, "Enter seed(press S when done): ");
        String seed = solicitNCharsInput();
        return Long.parseLong(seed);
    }

    public static String solicitNCharsInput() {
        String build = "";
        boolean exit = false;
        while(!exit){
            if(StdDraw.hasNextKeyTyped()){
                char c = Character.toLowerCase(StdDraw.nextKeyTyped());
                if(Character.isDigit(c)){
                    build += c;
                    drawFrame(build);
                }
                else if(c == 's'){
                    break;
                }
            }
        }
        return build;
    }

    public static void drawFrame(String s) {
        //TODO: Take the string and display it in the center of the screen
        //TODO: If game is not over, display relevant game information at the top of the screen
        StdDraw.clear(Color.BLACK);
        Font font = new Font("sans serif", Font.BOLD, 30);
        StdDraw.setPenColor(StdDraw.WHITE);
        StdDraw.setFont(font);
        StdDraw.text(20, 20, s);
        StdDraw.show();
        StdDraw.pause(500);
    }
}
